name: Publish ALL (VSIX, UI App, CLI App)

on:
  release:
    types: [published]

env:
  SOLUTION_PATH: 'LHQ_vs2022.sln'
  VSIX_PROJECT_PATH: 'src/VsExtension2022/VsExtension2022.csproj'
  BUILD_CONFIGURATION: 'Debug'
  VKP_VERSION: '0.0.1369-g1d5c984'
  NODE_VERSION: '20.x'
  REGISTRY_URL: 'https://npm.pkg.github.com'

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Setup NuGet
        uses: NuGet/setup-nuget@v2

      - uses: pnpm/action-setup@v4
        name: Install pnpm
        with:
          version: 10
          run_install: false

      - name: Setup Node.js for GitHub Packages
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: ${{ env.REGISTRY_URL }}
          scope: '@psulek'
          cache: 'pnpm'
          cache-dependency-path: 'src/Gen.Lib/pnpm-lock.yaml'

      - name: Install global tools
        run: |
          echo "Installing semver tool"
          pnpm add -g semver

      - name: Validate release tag value
        id: validate_tag
        uses: ./.github/actions/validate-tag
        with:
          tag: ${{ github.event.release.tag_name }}

      - name: Update tag environment variables
        shell: bash
        run: | 
          echo "TAG_VERSION=${{ steps.validate_tag.outputs.tag_version }}" >> $GITHUB_ENV
          echo "TAG_VALID=${{ steps.validate_tag.outputs.tag_valid }}" >> $GITHUB_ENV

      - name: Verify tag validity
        shell: bash
        if: env.TAG_VALID == '0'
        run: |
          echo "TAG_VALID=${{ env.TAG_VALID }} , TAG_VERSION=${{ env.TAG_VERSION }}"
          echo "Error: The provided release tag '${{ github.event.release.tag_name }}' is not valid."
          exit 1
          
      - name: Check Marketplace for existing version
        shell: bash
        run: |
          # Extract version from vsixmanifest
          VSIX_MANIFEST="src/VsExtension2022/source.extension.vsixmanifest"
          TARGET_VERSION=$(grep -oE 'Identity[^>]*Version="[^"]+' "$VSIX_MANIFEST" | sed -E 's/.*Version="//')
          echo "Target version from manifest: $TARGET_VERSION"

          #   TARGET_VERSION="2025.0"
          #   echo "Using target version: $TARGET_VERSION (for testing purposes)"
          
          # Visual Studio Marketplace extension identifier
          PUBLISHER="scalehqsolutions"
          EXTENSION_NAME="lhqeditorvs2022"
          EXTENSION_ID="$PUBLISHER.$EXTENSION_NAME"
          
          # Query the Visual Studio Marketplace API
          bodyObj=$(cat <<EOF
          {"filters":[{"criteria":[{"filterType":7,"value":"$EXTENSION_ID"}]}],"flags":1}
          EOF
          )
          
          response=$(curl -s -X POST "https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery" \
            -H "Content-Type: application/json" \
            -H "Accept: application/json;api-version=3.0-preview.1" \
            -d "$bodyObj")
          
          # Check if extension exists
          extensionCount=$(echo "$response" | jq -r '.results[0].extensions | length')
          
          if [[ "$extensionCount" == "0" || "$extensionCount" == "null" ]]; then
            echo "Extension not found in Marketplace. This appears to be a new extension."
            exit 0
          fi
          
          # Get all versions
          versions=$(echo "$response" | jq -r '.results[0].extensions[0].versions[].version')
          echo "Published versions in Marketplace:"
          echo "$versions"
          
          # Check if target version already exists
          versionExists=$(echo "$response" | jq -r \
            --arg ver "$TARGET_VERSION" \
            '.results[0].extensions[0].versions[] | select(.version == $ver) | .version')
          
          if [[ "$versionExists" == "$TARGET_VERSION" ]]; then
            echo "Error: Version $TARGET_VERSION already exists in VS Marketplace."
            exit 1
          fi
          
          # Get the highest version in Marketplace
          highestMarketplaceVersion=$(echo "$versions" | sort -V | tail -n 1)
          echo "Highest version in Marketplace: $highestMarketplaceVersion"

          highestMarketplaceVersion=$(semver -c "$highestMarketplaceVersion")
          
          # Check if Marketplace version is greater than target version
          isGreater=$(semver -c "$highestMarketplaceVersion" -r ">$TARGET_VERSION" || echo "false")
          if [[ "$isGreater" == "$highestMarketplaceVersion" ]]; then
            echo "Error: Marketplace already contains a higher version ($highestMarketplaceVersion) than your manifest ($TARGET_VERSION)."
            exit 1
          fi
          
          echo "Version check passed. Ready to publish version $TARGET_VERSION"

      - name: Install VsixSignTool and Publish Tool
        run: |
          nuget install Microsoft.VSSDK.Vsixsigntool -Version 17.10.34916.79 -OutputDirectory tools
          nuget install Microsoft.VSSDK.BuildTools -Version 17.14.2120 -OutputDirectory tools

      - name: test vsixPublisher
        env:
          VSCE_PAT: ${{ secrets.VSCE_PAT }}
        run: |
          $vsixPublisher = Get-ChildItem -Path tools -Filter "VsixPublisher.exe" -Recurse | Select-Object -First 1

          if (-not $vsixPublisher) {
            Write-Error "VsixPublisher.exe not found!"
            exit 1
          }

          # & $vsixPublisher.FullName help

      - name: Restore NuGet packages
        run: nuget restore ${{ env.SOLUTION_PATH }} -Verbosity quiet
      
      - name: Set token config
        working-directory: src/Gen.Lib
        shell: bash
        run: |
          echo "registry=https://registry.npmjs.org/" > .npmrc
          echo "@psulek:registry=https://npm.pkg.github.com" >> .npmrc
          echo "//npm.pkg.github.com/:_authToken=$GH_READ_PACKAGES_TOKEN" >> .npmrc
        env:
          GH_READ_PACKAGES_TOKEN: ${{ secrets.GH_READ_PACKAGES_TOKEN }}

      - name: Restore JS Libs dependencies for Gen.Lib
        working-directory: src/Gen.Lib
        shell: pwsh
        run: |
          & ./RestoreJSLib.ps1
        env:
          GH_READ_PACKAGES_TOKEN: ${{ secrets.GH_READ_PACKAGES_TOKEN }}

      - name: Copy README.md to VSIX project directory
        run: |
          Copy-Item README.md src\VsExtension2022\README.md

      - name: update application version
        uses: ./.github/actions/update-version
        with:
          new_version: ${{ env.TAG_VERSION }}
          app_project_path: 'src/App/'
          root_path: '.'

      - name: Build VSIX
        run: |
          msbuild ${{ env.SOLUTION_PATH }} `
            /p:Configuration=${{ env.BUILD_CONFIGURATION }} `
            /p:DeployExtension=false `
            /p:ZipPackageCompressionLevel=normal `
            /v:minimal

      - name: Find VSIX file
        id: find-vsix
        run: |
          $vsixFile = Get-ChildItem -Path . -Filter *.vsix -Recurse | Select-Object -First 1

          if (-not $vsixFile) {
            Write-Error "VSIX file not found!"
            exit 1
          }

          echo "VSIX_PATH=$($vsixFile.FullName)" >> $env:GITHUB_OUTPUT
          echo "VSIX_NAME=$($vsixFile.Name)" >> $env:GITHUB_OUTPUT

      - name: Publish to VS Marketplace
        env:
          VSCE_PAT: ${{ secrets.VSCE_PAT }}
        run: |
          $vsixPublisher = Get-ChildItem -Path tools -Filter "VsixPublisher.exe" -Recurse | Select-Object -First 1

          if (-not $vsixPublisher) {
            Write-Error "VsixPublisher.exe not found!"
            exit 1
          }

          cp README.md src/VsExtension2022/README.md          

          & $vsixPublisher.FullName publish `
            -payload "${{ steps.find-vsix.outputs.VSIX_PATH }}" `
            -personalAccessToken $env:VSCE_PAT

      - name: publish UI App
        uses: ./.github/actions/uiapp/
        with:
          mode: 'publish'
          vpk_version: ${{ env.VKP_VERSION }}
          prerelease: ${{ github.event.release.prerelease }}
          release_name: ${{ github.event.release.name || '' }}
          release_tag: ${{ github.event.release.tag_name }}
          new_version: ${{ env.TAG_VERSION }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: publish CLI App
        id: publish-cli
        working-directory: src/Gen.Cmd
        run: |
          echo "Publishing CLI App version ${{ env.TAG_VERSION }} ..."
          & ./publish-all.ps1
          
          $linuxArchive = "./_published/lhqcmd-portable-linux-x64.tar.gz"
          $winArchive = "./_published/lhqcmd-portable-win-x64.zip"
          
          if (-not (Test-Path $linuxArchive)) {
            Write-Error "Linux archive not found: $linuxArchive"
            exit 1
          }
          
          if (-not (Test-Path $winArchive)) {
            Write-Error "Windows archive not found: $winArchive"
            exit 1
          }
          
          Write-Host "Both CLI archives created successfully."
          
          # Resolve full paths to archive files
          # Example: D:\a\lhqeditor\lhqeditor\src\Gen.Cmd\_published\lhqcmd-portable-linux-x64.tar.gz
          $linuxPath = (Resolve-Path $linuxArchive).Path
          # Example: D:\a\lhqeditor\lhqeditor\src\Gen.Cmd\_published\lhqcmd-portable-win-x64.zip
          $winPath = (Resolve-Path $winArchive).Path
          
          Write-Host "CLI_LINUX_PATH=$linuxPath"
          Write-Host "CLI_WIN_PATH=$winPath"
          
          echo "CLI_LINUX_PATH=$linuxPath" >> $env:GITHUB_OUTPUT
          echo "CLI_WIN_PATH=$winPath" >> $env:GITHUB_OUTPUT

      - name: Upload assets files to GitHub Release
        uses: actions/github-script@v7
        env:
          vsixPath: ${{ steps.find-vsix.outputs.VSIX_PATH }}
          cliLinuxPath: ${{ steps.publish-cli.outputs.CLI_LINUX_PATH }}
          cliWinPath: ${{ steps.publish-cli.outputs.CLI_WIN_PATH }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const files = [
              process.env.vsixPath,
              process.env.cliLinuxPath,
              process.env.cliWinPath
            ];
            
            const uploadPromises = files.map(async (filePath) => {
              const fileName = path.basename(filePath);
              
              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: context.payload.release.id,
                name: fileName,
                data: await fs.promises.readFile(filePath)
              });
              
              core.notice(`File '${fileName}' was attached to the release successfully.`);
            });
            
            try {
              await Promise.all(uploadPromises);
            } catch (error) {
              core.setFailed(`Error uploading assets: ${error.message}`);
            }   
