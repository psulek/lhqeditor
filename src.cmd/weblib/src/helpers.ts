import {getNestedPropertyValue, isNullOrEmpty, iterateObject, sortBy, sortObjectByKey} from "./utils";
import {LhqModelResourceType, TemplateRootModel} from "./types";
import {HostEnv} from "./hostEnv";

export function registerHelpers() {
    Object.keys(helpersList).forEach(key => {
        // @ts-ignore
        Handlebars.registerHelper(key, helpersList[key]);
    });
}

const helpersList: Record<string, Function> = {};
helpersList['x-header'] = header;
helpersList['x-value'] = objValue;
helpersList['x-indent'] = indent;
helpersList['x-join'] = join;
helpersList['x-concat'] = concat;
helpersList['x-replace'] = replace;
helpersList['x-trimEnd'] = trimEnd;
helpersList['x-equals'] = equals;
helpersList['x-resourceComment'] = resourceComment;
helpersList['x-resourceParamNames'] = resourceParamNames;
helpersList['x-merge'] = merge;
helpersList['x-sortBy'] = sortBy;
helpersList['x-sortObject'] = sortObjectByKeyHelper;
helpersList['x-objCount'] = objCount;
//helpersList['x-each'] = eachsorted;

function header() {
    return `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool - Localization HQ Editor.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------`
}

function objValue(context: any, path: string) {
    const value = getNestedPropertyValue(context, path);
    return value !== undefined ? value : '';
}

function indent(count: number, options: any) {
    count = count < 0 ? 0 : count;
    // @ts-ignore
    var content = options.fn(this) as string;

    var paddedContent = content.split('\n')
        .map(line => '\t'.repeat(count) + line)
        .join('\n');

    return paddedContent;
}

/*
{{#join people delimiter=" and " start="0" end="2"}}{{name}} ({{gender}}, {{age}}){{/join}}
<h1>Jobs</h1>
{{join jobs delimiter=", " start="1" end="2"}}
*/
function join(items: any[], block: any) {
    var delimiter = block.hash.delimiter || ",",
        start = block.hash.start || 0,
        len = items ? items.length : 0,
        end = block.hash.end || len,
        out = "",
        decorator = block.hash.decorator || `"`;

    if (end > len) end = len;

    if ('function' === typeof block) {
        for (let i = start; i < end; i++) {
            if (i > start) out += delimiter;
            if ('string' === typeof items[i])
                out += items[i];
            else
                out += block(items[i]);
        }
        return out;
    } else {
        // @ts-ignore
        var res = [].concat(items).map(x => `${decorator}${x}${decorator}`).slice(start, end).join(delimiter);
        // @ts-ignore
        return new Handlebars.SafeString(res);
    }
}

// usage: {{ x-concat 'prop1' 'prop2' 'prop3' sep="," }}
function concat(...args: any[]) {
    const options = args.pop();
    const sep = options.hash.sep || ''; // Default to empty string if no separator is provided

    // @ts-ignore
    return args.filter(Boolean).join(sep);
}

function replace(value: string, block: any) {
    const what = block.hash.what || '',
        withStr = block.hash.with || '';

    if (!what || !withStr || (what === withStr)) {
        return value;
    }

    const regex = new RegExp(what, 'g');
    return value.replace(regex, withStr);
}

// usage: {{x-trimEnd fullPath "/index.html"}}
function trimEnd(input: string, endPattern: string): string {
    try {
        const regex = new RegExp(endPattern + '$');
        return input.replace(regex, '');
    } catch (error) {
        console.error('Invalid regex pattern:', endPattern);
        return input;
    }
}

// usage: {{#x-equals 'hello world' 'WorlD' cs="false" }}
// function ifEquals(input: any, value: any, block: any): boolean {
//     const cs = (block.hash.cs || "true").toString().toLowerCase() == "true";
//     const val1 = typeof input === "string" ? input : (input?.toString() ?? '');
//     const val2 = typeof value === "string" ? value : (value?.toString() ?? '');
//    
//     const equals = cs ? val1 === val2 : (val1.toLowerCase() === val2.toLowerCase());
//     if (equals) {
//         // @ts-ignore
//         return block.fn(this);
//     } else {
//         // @ts-ignore
//         return block.inverse(this);
//     }
// }

function equals(input: any, value: any, block: any): boolean {
    const cs = (block.hash.cs || "true").toString().toLowerCase() == "true";
    const val1 = typeof input === "string" ? input : (input?.toString() ?? '');
    const val2 = typeof value === "string" ? value : (value?.toString() ?? '');

    return cs ? val1 === val2 : (val1.toLowerCase() === val2.toLowerCase());
}

function resourceComment(resource: LhqModelResourceType, options: any): string {
    if (typeof resource === 'object') {
        const model = (options.hash.root as TemplateRootModel).model;
        const primaryLanguage = model?.model?.primaryLanguage ?? '';
        if (!isNullOrEmpty(primaryLanguage) && resource.values) {
            const resourceValue = resource.values[primaryLanguage]?.value;
            let propertyComment = isNullOrEmpty(resourceValue) ? resource.description : resourceValue;
            propertyComment = propertyComment.replace(/[\n\r]/g, '');
            propertyComment = propertyComment.replace(/\t/g, ' ');
            if (propertyComment.length > 80) {
                propertyComment = propertyComment.substring(0, 80);
            }
            // @ts-ignore
            return new Handlebars.SafeString(propertyComment);
        }
    }

    return '';
}

function resourceParamNames(resource: LhqModelResourceType, options: any): string {
    //HostEnv.debugLog('resourceParamNames>> ' + JSON.stringify(resource))
    if (typeof resource === 'object' && resource.parameters) {
        const withTypes = options?.hash?.withTypes ?? false;
        
        return Object.keys(resource.parameters).map(key => {
            return  withTypes ? `object ${key}`: key; 
        }).join(',');
    }
    
    return '';
}

function merge(context: any, options: any) {
    //HostEnv.debugLog('[merge]>> ' + JSON.stringify(options.hash ?? {}));

    return Object.assign({}, context, options.hash ?? {});
}

function sortObjectByKeyHelper(obj: Record<string, unknown>, options: any) {
    const sortOrder = options?.hash?.sortOrder ?? 'asc';
    return sortObjectByKey(obj, sortOrder);
}

function objCount(obj: Record<string, unknown>): number {
    return isNullOrEmpty(obj) ? 0 : Object.keys(obj).length;
}

/*
function eachsorted(context: any, options: any) {
    // Get the sort order from the helper's hash (default to 'asc')
    const sortOrder = options.hash.sortOrder || 'asc';

    // Sort the object by keys
    let result = '';
    if (context) {
        try {
            // @ts-ignore
            //HostEnv.debugLog('sortObjectByKey begin, for >> ' + JSON.stringify(this));
            const sortedObj = sortObjectByKey(context, sortOrder);

            // Use the built-in #each block to iterate over the sorted object
            for (const key in sortedObj) {
                if (sortedObj.hasOwnProperty(key)) {
                    // Create a new context with the current key and value
                    const context = {
                        key: key,
                        value: sortedObj[key]
                    };
                    // Render the block with the current context
                    result += options.fn(context);
                }
            }
        } catch (e) {
            HostEnv.debugLog('sortObjectByKey err, for >> ' + JSON.stringify(context));
        }
    }

    return result;
}
 */