import {
    copyObject,
    getNestedPropertyValue,
    hasItems,
    isNullOrEmpty,
    objCount,
    sortBy,
    sortObjectByKey,
    textEncode,
    valueAsBool,
} from "./utils";
import {LhqModelResourceType, TemplateRootModel} from "./types";
import {HostEnv} from "./hostEnv";

export function registerHelpers() {
    Object.keys(helpersList).forEach(key => {
        const fn = helpersList[key];
        // @ts-ignore
        Handlebars.registerHelper(key, () => debugLogAndExec(key, fn, ...arguments));
    });

    clearHelpersContext();
}

const helpersList: Record<string, Function> = {
    'x-header': headerHelper,
    'x-value': objValueHelper,
    'x-indent': indentHelper,
    'x-join': joinHelper,
    'x-concat': concatHelper,
    'x-replace': replaceHelper,
    'x-trimEnd': trimEndHelper,
    'x-equals': equalsHelper,
    'x-isTrue': isTrueHelper,
    'x-isFalse': isFalseHelper,
    'x-resourceComment': resourceCommentHelper,
    'x-resourceValue': resourceValueHelper,
    'x-resourceHasLang': resourceHasLangHelper,
    'x-resourceParamNames': resourceParamNamesHelper,
    'x-merge': mergeHelper,
    'x-sortBy': sortByHelper,
    'x-sortObject': sortObjectByKeyHelper,
    'x-objCount': objCountHelper,
    'x-hasItems': hasItemsHelper,
    'x-textEncode': textEncodeHelper,
    'x-host-webHtmlEncode': hostWebHtmlEncodeHelper,
    'x-render': renderHelper,
    'x-isNullOrEmpty': isNullOrEmptyHelper,
    'x-isNotNullOrEmpty': isNotNullOrEmptyHelper,
    'x-fn': callFunctionHelper,
    'x-logical': logicalHelper,
    'x-debugLog': debugLogHelper,
    'x-var': returnVarFromTempHelper
};

export function getKnownHelpers() {
    return Object.fromEntries(Object.keys(helpersList).map(key => [key, true]));
}

type HbsDataContext = {
    name: string;
    hash: Record<string, unknown>;
    data: Record<string, unknown>;
};

let dbgCounter = 0;
let globalVarTemp: Record<string, unknown> = {};
let helpersTimeTaken: Record<string, number> = {};
const trackHelperTimes = false;

export function clearHelpersContext() {
    dbgCounter = 0;
    globalVarTemp = {};
    //helpersTimeTaken = {};
}

function debugLogAndExec(helperName: string, fn: Function, ...args: any) {
    let debug = false;
    let header = '';
    let cnt = 0;

    if (arguments.length > 0) {
        const ctx = arguments[arguments.length - 1] as HbsDataContext;
        debug = valueAsBool(ctx.hash?._debug ?? false);
        if (debug) {
            cnt = ++dbgCounter;
            const debugLog = (ctx.hash?._debugLog ?? '').toString();
            const hash = copyObject(ctx.hash ?? {}, ['_debug', '_debugLog']);
            const restArgs = Array.from(args).slice(0, -1);
            header = `[${cnt}#${ctx.name}](${debugLog}) hash: ${JSON.stringify(hash, null, 0)}`;
            HostEnv.debugLog(`${header} ${JSON.stringify(restArgs, null, 0)}`);
        }
    }

    //HostEnv.debugLog(`[debugLogAndExec] fn: ${typeof fn} , arguments: ${JSON.stringify(arguments, null, 0)}, args: ${JSON.stringify(args, null, 0)}`);
    if (debug) {
        //HostEnv.debugLog(`${header}, arguments: ${JSON.stringify(arguments, null, 0)}, args: ${JSON.stringify(args, null, 0)}`);
    }

    let start = 0;
    if (trackHelperTimes) {
        start = Date.now();
    }

    // @ts-ignore
    const res = fn.call(this, ...args);

    if (trackHelperTimes) {
        const duration = Date.now() - start;
        helpersTimeTaken[helperName] = (helpersTimeTaken[helperName] ?? 0) + duration;
    }

    if (debug) {
        HostEnv.debugLog(`${header}, result: ${JSON.stringify(res, null, 0)}`);
    }

    return res;
}

export function debugHelpersTimeTaken(): void {
    if (!trackHelperTimes) {
        return;
    }

    let totalDuration = 0;
    Object.keys(helpersTimeTaken).forEach(key => {
        const duration = helpersTimeTaken[key] ?? 0;
        totalDuration += duration;

        HostEnv.debugLog(`helper '${key}' taken total: ${formatDuration(duration)}`);
    });

    HostEnv.debugLog(`All helpers taken total: ${formatDuration(totalDuration)}`);
}

function formatDuration(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const milliseconds = ms % 1000;

    return seconds > 0
        ? `${seconds} second${seconds > 1 ? 's' : ''} and ${milliseconds} ms`
        : `${milliseconds} ms`;
}

function headerHelper() {
    return `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool - Localization HQ Editor.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------`
}

function objValueHelper(context: any, path: string) {
    const value = getNestedPropertyValue(context, path);
    return value !== undefined ? value : '';
}

function indentHelper(count: number, options: any) {
    count = count < 0 ? 0 : count;
    // @ts-ignore
    var content = options.fn(this) as string;

    var paddedContent = content.split('\n')
        .map(line => '\t'.repeat(count) + line)
        .join('\n');

    return paddedContent;
}

/*
{{#join people delimiter=" and " start="0" end="2"}}{{name}} ({{gender}}, {{age}}){{/join}}
<h1>Jobs</h1>
{{join jobs delimiter=", " start="1" end="2"}}
*/
function joinHelper(items: any[], options: any) {

    // if (dbgCounter === 0) {
    //     dbgCounter = 1;
    //     // @ts-ignore
    //     HostEnv.debugLog(`[joinHelper] items: ${typeof items}, ${items.name} options: ${JSON.stringify(options)}`);
    // }

    var delimiter = options.hash?.delimiter || ",",
        start = options.hash?.start || 0,
        len = items ? items.length : 0,
        end = options.hash?.end || len,
        out = "",
        decorator = options.hash?.decorator || `"`;

    if (end > len) end = len;

    if ('function' === typeof options) {
        for (let i = start; i < end; i++) {
            if (i > start) out += delimiter;
            if ('string' === typeof items[i])
                out += items[i];
            else
                out += options(items[i]);
        }
        return out;
    } else {
        // @ts-ignore
        var res = [].concat(items).map(x => `${decorator}${x}${decorator}`).slice(start, end).join(delimiter);
        // @ts-ignore
        return new Handlebars.SafeString(res);
    }
}

// usage: {{ x-concat 'prop1' 'prop2' 'prop3' sep="," }}
function concatHelper(...args: any[]) {
    const options = args.pop();
    const sep = options.hash?.sep || ''; // Default to empty string if no separator is provided

    return saveResultToTempData(options, () => args.filter(x => !isNullOrEmpty(x)).join(sep));
    //return saveResultToTempData(() => args.filter(x => !isNullOrEmpty(x)).join(sep), ...arguments);

    // @ts-ignore
    //return args.filter(x => !isNullOrEmpty(x)).join(sep);
}

function saveResultToTempData(options: any, fn: () => any): any {
    const res = fn();
    const varName = options?.hash?.var;
    if (!isNullOrEmpty(varName)) {
        globalVarTemp[varName] = res;
    }

    return res;
}

// function saveResultToTempData(fn: Function, ...args: any): any {
//     // @ts-ignore
//     const res = fn.call(this, ...args);
//     if (arguments.length > 0) {
//         const ctx = arguments[arguments.length - 1] as HbsDataContext;
//         const varName = ctx?.hash?.var;
//
//         if (!isNullOrEmpty(varName)) {
//             ctx.data['temp'] = ctx.data['temp'] ?? {};
//             // @ts-ignore
//             ctx.data['temp'][varName] = res;
//         }
//     }
//    
//     return res;
// }

function replaceHelper(value: string, options: any) {
    const what = options.hash?.what || '',
        withStr = options.hash?.with || '';

    if (!what || !withStr || (what === withStr)) {
        return value;
    }

    const regex = new RegExp(what, 'g');
    return value.replace(regex, withStr);
}

// usage: {{x-trimEnd fullPath "/index.html"}}
function trimEndHelper(input: string, endPattern: string): string {
    try {
        const regex = new RegExp(endPattern + '$');
        return input.replace(regex, '');
    } catch (error) {
        HostEnv.debugLog('Invalid regex pattern:' + endPattern);
        return input;
    }
}

function equalsHelper(input: any, value: any, options: any): boolean {
    const {cs, val1, val2} = getDataForCompare(input, value, options)
    return cs ? val1 === val2 : (val1.toLowerCase() === val2.toLowerCase());
}

function isTrueHelper(input: any): boolean {
    return input === true;
}

function isFalseHelper(input: any): boolean {
    return input === false
}

function getDataForCompare(input: any, value: any, options: any): { cs: boolean, val1: string, val2: string } {
    const cs = (options.hash?.cs || "true").toString().toLowerCase() == "true";
    const val1 = typeof input === "string" ? input : (input?.toString() ?? '');
    const val2 = typeof value === "string" ? value : (value?.toString() ?? '');
    return {cs: cs, val1, val2};
}

function logicalHelper(input: any, value: any, options: any): boolean {
    const op = (options.hash?.op || 'and').toLowerCase();
    if (op === 'and') {
        //return input === value;
        return (input === true) && (value === true);
    } else if (op === 'or') {
        //return input || value;
        return (input === true) || (value === true);
    }

    return false;
}

function trimComment(value: string): string {
    if (isNullOrEmpty(value)) {
        return '';
    }

    let trimmed = false;
    var idxNewLine = value.indexOf('\r\n');

    if (idxNewLine == -1) {
        idxNewLine = value.indexOf('\n');
    }

    if (idxNewLine == -1) {
        idxNewLine = value.indexOf('\r');
    }

    if (idxNewLine > -1) {
        value = value.substring(0, idxNewLine);
        trimmed = true;
    }

    if (value.length > 80) {
        value = value.substring(0, 80);
        trimmed = true;
    }

    if (trimmed) {
        value += "...";
    }

    return value.replace('\t', ' ');
}

function resourceCommentHelper(resource: LhqModelResourceType, options: any): string {
    if (typeof resource === 'object') {
        const model = (options.hash?.root as TemplateRootModel).model;
        const primaryLanguage = model?.model?.primaryLanguage ?? '';
        if (!isNullOrEmpty(primaryLanguage) && resource.values) {
            const resourceValue = resource.values[primaryLanguage]?.value;
            let propertyComment = isNullOrEmpty(resourceValue) ? resource.description : resourceValue;
            //try {
            propertyComment = trimComment(propertyComment);
            // }
            // catch(err) {
            //     const s1 = `res_value_${primaryLanguage}: ${resource.values[primaryLanguage]?.value}`;
            //     const s2 = 'res_name: ' + resource.getName!();
            //     HostEnv.debugLog('[resourceCommentHelper] failed for: ' + (isNullOrEmpty(propertyComment) ? 'null': JSON.stringify(propertyComment)) + `, ${s1}, ${s2}`);
            // }
            // @ts-ignore
            return new Handlebars.SafeString(propertyComment);
        }
    }

    return '';
}

function resourceValueHelper(resource: LhqModelResourceType, options: any): string {
    if (typeof resource === 'object') {
        const lang = options.hash?.lang ?? '';
        const trim = options.hash?.trim ?? false;

        if (!isNullOrEmpty(lang)) {
            const res = resource?.values?.[lang]?.value ?? '';
            return trim ? res.trim() : res;
        }
    }

    return '';
}

function resourceHasLangHelper(resource: LhqModelResourceType, options: any): boolean {
    if (typeof resource === 'object') {
        const lang = options.hash?.lang ?? '';
        if (!isNullOrEmpty(lang) && resource.values && resource.values[lang]) {
            return true;
        }
    }

    return false;
}

function resourceParamNamesHelper(resource: LhqModelResourceType, options: any): string {
    if (typeof resource === 'object' && resource.parameters) {
        const withTypes = options?.hash?.withTypes ?? false;

        return Object.keys(resource.parameters).map(key => {
            return withTypes ? `object ${key}` : key;
        }).join(',');
    }

    return '';
}

function mergeHelper(context: any, options: any) {
    return Object.assign({}, context, options.hash ?? {});
}

function sortByHelper<T>(source: T[], propName?: string, sortOrder: 'asc' | 'desc' = 'asc'): T[] {
    return sortBy<T>(source, propName, sortOrder);
}

function sortObjectByKeyHelper(obj: Record<string, unknown>, options: any) {
    const sortOrder = options?.hash?.sortOrder ?? 'asc';
    return sortObjectByKey(obj, sortOrder);
}

function objCountHelper<T>(obj: Record<string, T> | Array<T> | undefined): number {
    return objCount<T>(obj);
}

function hasItemsHelper<T>(obj: Record<string, T> | Array<T> | undefined): boolean {
    return hasItems<T>(obj);
}

function textEncodeHelper(str: string, options: any): string {
    const mode = options?.hash?.mode ?? 'html';
    const quotes = options?.hash?.quotes ?? false;
    const s = textEncode(str, {mode: mode, quotes});
    // @ts-ignore
    return new Handlebars.SafeString(s);
}

function hostWebHtmlEncodeHelper(str: string): string {
    if (isNullOrEmpty(str)) {
        return str;
    }

    const encoded = HostEnv.webHtmlEncode(str);

    // @ts-ignore
    return new Handlebars.SafeString(encoded);
}

function renderHelper(input: any, options: any): string {
    const when = options?.hash?.when ?? true;
    // @ts-ignore
    return when ? input : '';
}

function isNullOrEmptyHelper<T>(value: T | null | undefined | ''): value is undefined | null | '' {
    return isNullOrEmpty(value);
}

function isNotNullOrEmptyHelper(input: any): boolean {
    return !isNullOrEmpty(input);
}

function callFunctionHelper(fn: Function, ...args: any): any {
    let fnArgs = undefined;
    if (arguments.length > 0) {
        //const ctx = arguments[arguments.length - 1] as HbsDataContext;
        fnArgs = Array.from(args).slice(0, -1);
    }

    return fnArgs === undefined ? fn() : fn(...fnArgs);
}

// function callFunctionHelper(fn: any): any {
//     return fn();
// }

function debugLogHelper(...args: any[]): string {
    HostEnv.debugLog(args.join(' '));
    return '';
}

function returnVarFromTempHelper(name: string, options: any): any {
    //const name = options?.hash?.name;
    const defaultVal = options?.hash?.default;

    if (isNullOrEmpty(name)) {
        return '';
    }

    return globalVarTemp[name] ?? defaultVal;
}