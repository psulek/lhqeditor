import {
    getNestedPropertyValue, hasItems,
    isNullOrEmpty, objCount,
    sortBy,
    sortObjectByKey, textEncode,
} from "./utils";
import {LhqModelResourceType, TemplateRootModel} from "./types";
import {HostEnv} from "./hostEnv";

export function registerHelpers() {
    Object.keys(helpersList).forEach(key => {
        // @ts-ignore
        Handlebars.registerHelper(key, helpersList[key]);
    });
}

const helpersList: Record<string, Function> = {};
helpersList['x-header'] = header;
helpersList['x-value'] = objValue;
helpersList['x-indent'] = indent;
helpersList['x-join'] = join;
helpersList['x-concat'] = concat;
helpersList['x-replace'] = replace;
helpersList['x-trimEnd'] = trimEnd;
helpersList['x-equals'] = equals;
helpersList['x-isTrue'] = isTrueHelper;
helpersList['x-isFalse'] = isFalseHelper;
helpersList['x-resourceComment'] = resourceComment;
helpersList['x-resourceValue'] = resourceValue;
helpersList['x-resourceHasLang'] = resourceHasLang;
helpersList['x-resourceParamNames'] = resourceParamNames;
helpersList['x-merge'] = merge;
helpersList['x-sortBy'] = sortBy;
helpersList['x-sortObject'] = sortObjectByKeyHelper;
helpersList['x-objCount'] = objCount;
helpersList['x-hasItems'] = hasItems;
helpersList['x-textEncode'] = textEncodeHelper;
helpersList['x-host-webHtmlEncode'] = hostWebHtmlEncodeHelper;
helpersList['x-render'] = renderHelper;
helpersList['x-isNullOrEmpty'] = isNullOrEmpty;
helpersList['x-isNotNullOrEmpty'] = isNotNullOrEmptyHelper;
helpersList['x-fn'] = callFunctionHelper;
helpersList['x-logical'] = logicalOperatorHelper;
helpersList['x-debugLog'] = debugLogHelper;

//helpersList['x-each'] = eachsorted;

function header() {
    return `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool - Localization HQ Editor.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------`
}

function objValue(context: any, path: string) {
    const value = getNestedPropertyValue(context, path);
    return value !== undefined ? value : '';
}

function indent(count: number, options: any) {
    count = count < 0 ? 0 : count;
    // @ts-ignore
    var content = options.fn(this) as string;

    var paddedContent = content.split('\n')
        .map(line => '\t'.repeat(count) + line)
        .join('\n');

    return paddedContent;
}

/*
{{#join people delimiter=" and " start="0" end="2"}}{{name}} ({{gender}}, {{age}}){{/join}}
<h1>Jobs</h1>
{{join jobs delimiter=", " start="1" end="2"}}
*/
function join(items: any[], block: any) {
    var delimiter = block.hash.delimiter || ",",
        start = block.hash.start || 0,
        len = items ? items.length : 0,
        end = block.hash.end || len,
        out = "",
        decorator = block.hash.decorator || `"`;

    if (end > len) end = len;

    if ('function' === typeof block) {
        for (let i = start; i < end; i++) {
            if (i > start) out += delimiter;
            if ('string' === typeof items[i])
                out += items[i];
            else
                out += block(items[i]);
        }
        return out;
    } else {
        // @ts-ignore
        var res = [].concat(items).map(x => `${decorator}${x}${decorator}`).slice(start, end).join(delimiter);
        // @ts-ignore
        return new Handlebars.SafeString(res);
    }
}

// usage: {{ x-concat 'prop1' 'prop2' 'prop3' sep="," }}
function concat(...args: any[]) {
    const options = args.pop();
    const sep = options.hash.sep || ''; // Default to empty string if no separator is provided

    // @ts-ignore
    //return args.filter(Boolean).join(sep);
    return args.join(sep);
}

function replace(value: string, block: any) {
    const what = block.hash.what || '',
        withStr = block.hash.with || '';

    if (!what || !withStr || (what === withStr)) {
        return value;
    }

    const regex = new RegExp(what, 'g');
    return value.replace(regex, withStr);
}

// usage: {{x-trimEnd fullPath "/index.html"}}
function trimEnd(input: string, endPattern: string): string {
    try {
        const regex = new RegExp(endPattern + '$');
        return input.replace(regex, '');
    } catch (error) {
        console.error('Invalid regex pattern:', endPattern);
        return input;
    }
}

// usage: {{#x-equals 'hello world' 'WorlD' cs="false" }}
// function ifEquals(input: any, value: any, block: any): boolean {
//     const cs = (block.hash.cs || "true").toString().toLowerCase() == "true";
//     const val1 = typeof input === "string" ? input : (input?.toString() ?? '');
//     const val2 = typeof value === "string" ? value : (value?.toString() ?? '');
//    
//     const equals = cs ? val1 === val2 : (val1.toLowerCase() === val2.toLowerCase());
//     if (equals) {
//         // @ts-ignore
//         return block.fn(this);
//     } else {
//         // @ts-ignore
//         return block.inverse(this);
//     }
// }

function equals(input: any, value: any, block: any): boolean {
    /*const cs = (block.hash.cs || "true").toString().toLowerCase() == "true";
    const val1 = typeof input === "string" ? input : (input?.toString() ?? '');
    const val2 = typeof value === "string" ? value : (value?.toString() ?? '');*/

    const {cs, val1, val2} = getDataForCompare(input, value, block)
    return cs ? val1 === val2 : (val1.toLowerCase() === val2.toLowerCase());
}

function isTrueHelper(input: any): boolean {
    return input === true;
}

function isFalseHelper(input: any): boolean {
    return input === false
}

function getDataForCompare(input: any, value: any, block: any): { cs: boolean, val1: string, val2: string } {
    const cs = (block.hash.cs || "true").toString().toLowerCase() == "true";
    const val1 = typeof input === "string" ? input : (input?.toString() ?? '');
    const val2 = typeof value === "string" ? value : (value?.toString() ?? '');
    return {cs: cs, val1, val2};
}

function logicalOperatorHelper(input: any, value: any, block: any): boolean {
    const op = block.hash.op || 'and';
    if (op === 'and') {
        return input === value;
    } else if (op === 'or') {
        return input || value;
    }

    return false;
}

// function compareHelper(input: any, value: any, block: any): boolean {
//     const cs = (block.hash.cs || "true").toString().toLowerCase() == "true";
//     const {cs, val1, val2} = getDataForCompare(input, value, block)
//
// }

function trimComment(value: string): string {
    let trimmed = false;
    var idxNewLine = value.indexOf('\r\n');

    if (idxNewLine == -1) {
        idxNewLine = value.indexOf('\n');
    }

    if (idxNewLine == -1) {
        idxNewLine = value.indexOf('\r');
    }

    if (idxNewLine > -1) {
        value = value.substring(0, idxNewLine);
        trimmed = true;
    }

    if (value.length > 80) {
        value = value.substring(0, 80);
        trimmed = true;
    }

    if (trimmed) {
        value += "...";
    }

    return value.replace('\t', ' ');
}

function resourceComment(resource: LhqModelResourceType, options: any): string {
    if (typeof resource === 'object') {
        const model = (options.hash.root as TemplateRootModel).model;
        const primaryLanguage = model?.model?.primaryLanguage ?? '';
        if (!isNullOrEmpty(primaryLanguage) && resource.values) {
            const resourceValue = resource.values[primaryLanguage]?.value;
            let propertyComment = isNullOrEmpty(resourceValue) ? resource.description : resourceValue;
            propertyComment = trimComment(propertyComment);
            // @ts-ignore
            return new Handlebars.SafeString(propertyComment);
        }
    }

    return '';
}

function resourceValue(resource: LhqModelResourceType, options: any): string {
    if (typeof resource === 'object') {
        const lang = options.hash.lang ?? '';
        const trim = options.hash.trim ?? false;

        if (!isNullOrEmpty(lang)) {
            const res = resource?.values?.[lang]?.value ?? '';
            return trim ? res.trim() : res; 
        }
    }

    return '';
}

function resourceHasLang(resource: LhqModelResourceType, options: any): boolean {
    if (typeof resource === 'object') {
        const lang = options.hash.lang ?? '';
        if (!isNullOrEmpty(lang) && resource.values && resource.values[lang]) {
            return true;
        }
    }

    return false;
}

function resourceParamNames(resource: LhqModelResourceType, options: any): string {
    if (typeof resource === 'object' && resource.parameters) {
        const withTypes = options?.hash?.withTypes ?? false;

        return Object.keys(resource.parameters).map(key => {
            return withTypes ? `object ${key}` : key;
        }).join(',');
    }

    return '';
}

function merge(context: any, options: any) {
    return Object.assign({}, context, options.hash ?? {});
}

function sortObjectByKeyHelper(obj: Record<string, unknown>, options: any) {
    const sortOrder = options?.hash?.sortOrder ?? 'asc';
    return sortObjectByKey(obj, sortOrder);
}

function textEncodeHelper(str: string, options: any): string {
    const mode = options?.hash?.mode ?? 'html';
    const quotes = options?.hash?.quotes ?? false;
    const s = textEncode(str, {mode: mode, quotes});
    // @ts-ignore
    return new Handlebars.SafeString(s);
}

function hostWebHtmlEncodeHelper(str: string): string {
    if (isNullOrEmpty(str)) {
        return str;
    }

    const encoded = HostEnv.webHtmlEncode(str);

    // @ts-ignore
    return new Handlebars.SafeString(encoded);
}

function renderHelper(input: any, options: any): string {
    const when = options?.hash?.when ?? true;

    // @ts-ignore
    return when ? input : '';
}

function isNotNullOrEmptyHelper(input: any): boolean {
    return !isNullOrEmpty(input);
}

function callFunctionHelper(fn: any): any {
    // HostEnv.debugLog("[callFunctionHelper] fn: " + typeof fn + " , " + JSON.stringify(fn));

    return fn();
}

function debugLogHelper(...args: any[]): string {
    HostEnv.debugLog(args.join(' '));
    return '';
} 