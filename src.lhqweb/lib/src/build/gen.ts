import fsp from 'node:fs/promises';
import * as fse from 'fs-extra'
import { Generator, GeneratorHostDataKeys } from '../generator';
import path from 'node:path';
import { isNullOrEmpty, safeJsonParse } from '../utils';
import type { GeneratedFile, LhqModel } from '../api';
import { HostEnvironmentDefault } from './hostEnv';
import { GeneratorInitialization } from '../types';
import { Duration } from '../duration';
import { findOwnerCsProjectFile } from './cliUtils';
import { getRootNamespace } from '../generatorUtils';

const fileHeader = `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool - Localization HQ Editor.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------`;

const templates = [
    'NetCoreResxCsharp01',
    'NetResx',
    'TypescriptJson01',
    'TypescriptJson01Json',
    'NetFwResxCsharp01',
    'WpfResxCsharp01',
    'WinFormsResxCsharp01'
];


export async function generateFromLhq(lhqFileName: string, csProjectFileName: string, outputDir: string,
    hostData: Record<string, unknown>): Promise<void> {

    const generatorInit: GeneratorInitialization = {
        hbsTemplates: {},
        hostEnvironment: new HostEnvironmentDefault()
    };

    const templateLoaders = templates.map(async (templateId) => {
        generatorInit.hbsTemplates[templateId] = await readHbsFile(templateId + '.hbs');
    });

    await Promise.all(templateLoaders);

    const lhqFile = await fsp.readFile(lhqFileName, { encoding: 'utf-8' });
    const model = safeJsonParse<LhqModel>(lhqFile);

    Generator.initialize(generatorInit);

    let rootNamespace = hostData[GeneratorHostDataKeys.namespace]
    let csProjFound = false;
    if (isNullOrEmpty(rootNamespace)) {
        let t4FileName = '';
        if (isNullOrEmpty(csProjectFileName)) {
            const findResult = await findOwnerCsProjectFile(lhqFileName);

            if (!isNullOrEmpty(findResult.csProjFileName)) {
                console.log(`Found '${csProjectFileName}' associated with '${lhqFileName}'.`);
                csProjFound = true;
                csProjectFileName = findResult.csProjFileName;
                t4FileName = findResult.t4FileName;
                rootNamespace = findResult.namespace;
            }
        } else {
            t4FileName = path.basename(lhqFileName) + '.tt';
        }

        if (isNullOrEmpty(rootNamespace)) {
            let csProjectFileContent = '';
            if (await fse.pathExists(csProjectFileName)) {
                csProjectFileContent = await fsp.readFile(csProjectFileName, { encoding: 'utf-8' });
            }

            rootNamespace = getRootNamespace(path.basename(lhqFileName), t4FileName, csProjectFileName, csProjectFileContent);
        }

        hostData[GeneratorHostDataKeys.namespace] = rootNamespace ?? '';
    }

    if (isNullOrEmpty(hostData[GeneratorHostDataKeys.fileHeader])) {
        hostData[GeneratorHostDataKeys.fileHeader] = fileHeader;
    }

    const generator = new Generator();

    const duration = Duration.start();
    const result = generator.generate(lhqFileName, model, csProjectFileName, hostData);
    console.log(`Generated ${result.generatedFiles.length} files in ${duration.elapsedTime}.\n------------\n`);

    const name = path.parse(lhqFileName).name;
    const output = path.resolve(__dirname, '../../temp/' + name);

    console.log(`Output directory: ${output}`);
    const saveFilesMap = result.generatedFiles.map(async (file) => {
        await saveGenFile(generator, file, output);
        console.log(`Saved file ${file.fileName}.`);
    });

    await Promise.all(saveFilesMap);
}

async function saveGenFile(generator: Generator, generatedFile: GeneratedFile, outputPath?: string): Promise<void> {
    const content = generator.getFileContent(generatedFile, true);
    const bom = generatedFile.bom ? '\uFEFF' : '';
    const encodedText = Buffer.from(bom + content, 'utf8');

    const fileName = !outputPath ? generatedFile.fileName : path.join(outputPath, generatedFile.fileName);
    const dir = path.dirname(fileName);

    await fse.ensureDir(dir);
    await fsp.writeFile(fileName, encodedText, { encoding: 'utf8' });
}

async function readHbsFile(fileName: string): Promise<string> {
    const file = path.resolve(__dirname, '..', 'hbs', fileName);
    return await fsp.readFile(file, { encoding: 'utf-8' });
}