#!/usr/bin/env node

import path from 'node:path';
import { Command } from '@commander-js/extra-typings';
import { createColors } from "picocolors"
import fse from 'fs-extra';
import { glob } from 'glob';

type Colors = ReturnType<typeof createColors>;


import {
    Duration, Generator, GeneratorHostDataKeys,
    generatorUtils, isNullOrEmpty, jsonParseOrDefault, tryRemoveBOM,
    HostEnvironment, objCount,
    getLibraryVersion,
} from './index';


import type { GeneratedFile, LhqModel, CSharpNamespaceInfo, GeneratorInitialization } from './index'

const fileHeader = `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool - Localization HQ Editor.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------`;

export type CsProjectInfo = {
    csProjFileName: string;
    t4FileName: string;
    namespace: string;
};

let pc: Colors = createColors();

const init_cwd = process.env.INIT_CWD!;
const npm_script_file = path.join(init_cwd, 'node_modules');
const is_npm_script = __dirname.startsWith(npm_script_file);
const cwd = is_npm_script ? __dirname : process.cwd();


const cliToolHeader = (): string => pc.bold(`LHQ Code Template Generator ${pc.gray(`(${getLibraryVersion()})`)}\n`);

class HostEnvironmentCli extends HostEnvironment {
    public pathCombine(path1: string, path2: string): string {
        return path.join(path1, path2);
    }
}

async function findOwnerCsProjectFile(lhqModelFileName: string): Promise<CsProjectInfo> {
    let namespaceInfo: CSharpNamespaceInfo | undefined = undefined;

    if (await fse.pathExists(lhqModelFileName)) {
        const dir = path.dirname(lhqModelFileName);

        const csProjectFiles = await glob('*.csproj', { cwd: dir, nodir: true });

        const namespaceResults: Array<CSharpNamespaceInfo> = [];

        for (const csProj of csProjectFiles) {
            const csProjPath = path.join(dir, csProj);

            if (await fse.pathExists(csProjPath)) {
                const ttFile = path.basename(lhqModelFileName) + '.tt';
                const csProjContent = await safeReadFile(csProjPath);

                const namespaceInfo = generatorUtils.getRootNamespaceFromCsProj(path.basename(lhqModelFileName), ttFile, csProjPath, csProjContent);
                if (namespaceInfo) {
                    namespaceResults.push(namespaceInfo);
                }
            }
        }

        if (namespaceResults.length > 1) {
            const mutileRefs = namespaceResults.filter(x => x.referencedLhqFile || x.referencedT4File).length;
            if (mutileRefs > 1) {
                const lhq = path.basename(lhqModelFileName);
                const t4 = path.basename(lhqModelFileName) + '.tt';
                throw new Error(`Multiple C# project files found in directory '${dir}' that references either '${lhq}' or a '${t4}' file.\n` +
                    `Specify which C# project file to use with the '--project' argument.`
                );
            }

            namespaceInfo = namespaceResults.find(x => (x.referencedLhqFile || x.referencedT4File) && !isNullOrEmpty(x.namespace));
            namespaceInfo = namespaceInfo || namespaceResults.find(x => !isNullOrEmpty(x.namespace)) || namespaceResults[0];
        } else if (namespaceResults.length === 1) {
            namespaceInfo = namespaceResults[0];
        }
    }

    const csProjFileName = namespaceInfo?.csProjectFileName ?? '';
    const t4FileName = namespaceInfo?.t4FileName ?? '';
    let namespace = namespaceInfo?.namespace ?? '';

    if (isNullOrEmpty(namespace)) {
        namespace = isNullOrEmpty(csProjFileName) ? '' : path.basename(csProjFileName, path.extname(csProjFileName)).replace(' ', '_');
    }

    return { csProjFileName, t4FileName, namespace };
}

async function validateLhqModelFile(lhqFileName: string, verbose: boolean): Promise<void> {
    lhqFileName = path.resolve(lhqFileName);

    if (!await fse.pathExists(lhqFileName)) {
        throw new Error(`LHQ model file '${lhqFileName}' not found.`);
    }

    const lhqFile = await safeReadFile(lhqFileName);
    const model = jsonParseOrDefault<LhqModel>(lhqFile, {} as LhqModel, true);
    const valid = await generatorUtils.validateLhqModel(model);
    const resultStr = valid.success ? pc.greenBright('VALID:') : pc.redBright('INVALID:');
    const fileStr = pc.cyanBright(lhqFileName);
    const validStr = valid.success
        ? `File ${fileStr} has valid schema.`
        : `File '${fileStr}' has invalid schema.\n${pc.redBright(valid.error ?? '')}`;

    console.log(`${pc.bold(resultStr)} ${validStr}`);
}

async function safeReadFile(fileName: string): Promise<string> {
    if (!(await fse.pathExists(fileName))) {
        throw new Error(`File '${fileName}' not found.`);
    }

    const content = await fse.readFile(fileName, { encoding: 'utf-8' });
    return isNullOrEmpty(content) ? '' : tryRemoveBOM(content);
}
async function generateFromLhq(hbsTemplatesDir: string, lhqFileName: string, csProjectFileName: string, outputDir: string,
    hostData: Record<string, unknown>, verbose: boolean): Promise<void> {

    lhqFileName = path.resolve(lhqFileName);

    if (!(await fse.pathExists(lhqFileName))) {
        throw new Error(`LHQ model file '${lhqFileName}' not found.`);
    }

    if (!isNullOrEmpty(csProjectFileName) && !(await fse.pathExists(csProjectFileName))) {
        throw new Error(`C# project file '${csProjectFileName}' not found.`);
    }

    const generatorInit: GeneratorInitialization = {
        hbsTemplates: {},
        hostEnvironment: new HostEnvironmentCli()
    };

    if (!(await fse.pathExists(hbsTemplatesDir))) {
        throw new Error(`LHQ templates directory '${hbsTemplatesDir}' not found.`);
    }

    const hbsFiles = await glob('*.hbs', { cwd: hbsTemplatesDir, nodir: true });

    if (hbsFiles.length === 0) {
        throw new Error(`LHQ templates directory '${hbsTemplatesDir}' is empty.`);
    }

    let cmdDataStr = '-';
    const hostDataCount = objCount(hostData);
    if (hostDataCount > 0) {
        const max = verbose ? hostDataCount : 2;
        cmdDataStr = '\n' + Object.entries(hostData)
            .map(([key, value]) => `   ${key}=${value}`)
            .slice(0, max)
            .join('\n');

        if (hostDataCount > max) {
            cmdDataStr += `\n   ... (${hostDataCount - max} more data)`;
        }
    }

    const templateLoaders = hbsFiles.map(async (hbsFile) => {
        const templateId = path.basename(hbsFile, path.extname(hbsFile));
        const fullFilePath = path.join(hbsTemplatesDir, hbsFile);
        generatorInit.hbsTemplates[templateId] = await safeReadFile(fullFilePath);
    });

    await Promise.all(templateLoaders);

    const lhqFile = await safeReadFile(lhqFileName);
    const model = JSON.parse(lhqFile) as LhqModel;

    Generator.initialize(generatorInit);

    let rootNamespace = hostData[GeneratorHostDataKeys.namespace]

    let csProjFound = false;
    if (isNullOrEmpty(rootNamespace)) {
        let t4FileName = '';
        if (isNullOrEmpty(csProjectFileName)) {
            const findResult = await findOwnerCsProjectFile(lhqFileName);

            if (!isNullOrEmpty(findResult.csProjFileName)) {
                //console.log(`Found '${csProjectFileName}' associated with '${lhqFileName}'.`);
                csProjFound = true;
                csProjectFileName = findResult.csProjFileName;
                t4FileName = findResult.t4FileName;
                rootNamespace = findResult.namespace;
            }
        } else {
            t4FileName = path.basename(lhqFileName) + '.tt';
        }

        if (isNullOrEmpty(rootNamespace)) {
            let csProjectFileContent = '';
            const csProjectExist = !isNullOrEmpty(csProjectFileName) && await fse.pathExists(csProjectFileName);
            if (csProjectExist) {
                csProjectFileContent = await safeReadFile(csProjectFileName);
            }

            rootNamespace = generatorUtils.getRootNamespaceFromCsProj(path.basename(lhqFileName), t4FileName, csProjectFileName, csProjectFileContent);
            if (isNullOrEmpty(rootNamespace) && csProjectExist) {
                rootNamespace = path.basename(csProjectFileName, path.extname(csProjectFileName)).replace(' ', '_');
            }
        }

        hostData[GeneratorHostDataKeys.namespace] = rootNamespace ?? '';
    }

    if (isNullOrEmpty(hostData[GeneratorHostDataKeys.fileHeader])) {
        hostData[GeneratorHostDataKeys.fileHeader] = fileHeader;
    }

    const hasCsProj = !isNullOrEmpty(csProjectFileName);

    console.log(`Starting code generating for:\n` +
        `- lhq model file: ${pc.yellow(lhqFileName)}
- c# project file: ${hasCsProj ? csProjectFileName : '-'} ${hasCsProj ? `(${csProjFound ? 'auto found' : 'cmd'})` : ''}
- out dir: ${outputDir}
- data: ${cmdDataStr}\n`);

    const generator = new Generator();

    const duration = Duration.start();
    const result = generator.generate(lhqFileName, model, hostData);
    const genFileCount = result.generatedFiles.length;
    console.log(`Generated ${pc.blueBright(genFileCount)} files in ${pc.blueBright(duration.elapsedTime)}.\n`);


    const output = path.resolve(outputDir);
    console.log(`Output directory: ${output}`);
    const saveFilesMap = result.generatedFiles.map(async (file) => {
        await saveGenFile(generator, file, output);
        console.log(`Saved file ${file.fileName}.`);
    });

    await Promise.all(saveFilesMap);
}

async function saveGenFile(generator: Generator, generatedFile: GeneratedFile, outputPath?: string): Promise<void> {
    const content = generator.getFileContent(generatedFile, true);
    const bom = generatedFile.bom ? '\uFEFF' : '';
    const encodedText = Buffer.from(bom + content, 'utf8');

    const fileName = !outputPath ? generatedFile.fileName : path.join(outputPath, generatedFile.fileName);
    const dir = path.dirname(fileName);

    await fse.ensureDir(dir);
    await fse.writeFile(fileName, encodedText, { encoding: 'utf8' });
}

(async () => {
    try {

        const args = process.argv.slice(2);
        const isVersion = args.length === 1 && args[0] === '-v' || args[0] === '--version';

        const noColorIdx = args.findIndex(a => ['--no-colors', '--no-color'].includes(a));
        const noColors = noColorIdx > -1;
        if (noColorIdx > -1) {
            args.splice(noColorIdx, 1);
        }

        const helpIdx = args.findIndex(a => ['--help', '-h', '/?'].includes(a));
        const isHelp = helpIdx > -1;
        if (helpIdx > -1) {
            args.splice(helpIdx, 1);
        }

        const lhqfile = args.length > 0 ? args.shift() ?? '' : '';

        if (noColors) {
            process.env['NO_COLOR'] = noColors ? '1' : '';
        }
        pc = createColors(noColors === false);

        const cliToolName = 'lhqcmd';
        const cliToolNameColor = pc.cyan(cliToolName);
        const cliCommand = (str: string) => pc.blueBright(str);
        const cliItalic = (str: string) => pc.italic(str);

        const hint = `* when [command] is omitted, the default command is: ${cliCommand('generate')}`;

        const program = new Command()
            .name(cliToolName)
            .description('Run various actions against LHQ files')
            .argument('<lhqfile>', 'The LHQ project file *.lhq (e.g., Strings.lhq)')
            //.enablePositionalOptions()
            .version(getLibraryVersion(), '-v, --version', 'output the version number')
            .option('--verbose', 'enable verbose output', false)
            .option('--no-color', 'disable color output')
            .addHelpText('beforeAll', cliToolHeader())
            .addHelpText(
                'after',
                `
${pc.bold('Examples:')}
  ${cliToolNameColor} file.lhq ${cliCommand('generate')} ${pc.yellow('Strings.lhq')} --project MyProject.csproj --out ./output --data namespace=Namespace1
  ${cliToolNameColor} file.lhq ${pc.yellow('Strings.lhq')} -o ./output
  ${cliToolNameColor} file.lhq ${cliCommand('validate')} ${pc.yellow('Strings.lhq')}

  ${cliItalic(hint)}
`);

        program.configureHelp({
            styleTitle: (str) => pc.bold(str),
            styleCommandText: (str) => pc.cyan(str),
            styleCommandDescription: (str) => pc.magentaBright(str),
            styleDescriptionText: (str) => pc.italic(str),
            styleOptionText: (str) => pc.gray(str),
            styleArgumentText: (str) => pc.yellow(str),
            styleSubcommandText: (str) => pc.blueBright(str),
        });

        const generateCommand = new Command('generate')
            .description('Run template generator associated with LHQ file')
            .usage('<lhqfile> [options]')
            .option('-p, --project <project>', 'The C# project file *.csproj (e.g., MyProject.csproj)')
            .option('-o, --out <out>', 'The output directory', '.')
            .option('-d, --data <data...>', 'Key-value pairs for host data (e.g., key=value)')
            .action(async (options) => {
                let hostData: Record<string, string>;
                const verbose = program.opts().verbose ?? false;

                if (options.data) {
                    hostData = options.data.reduce<{ [key: string]: string }>((acc, item) => {
                        const [key, value] = (item as string).split('=');
                        acc[key] = value;
                        return acc;
                    }, {});
                } else {
                    hostData = {};
                }


                const hbsTemplatesDir = path.join(cwd, 'hbs');
                await generateFromLhq(hbsTemplatesDir, lhqfile, options.project ?? '', options.out ?? '.', hostData, verbose);
            });

        const validateCommand = new Command('validate')
            .description('Validate the input LHQ file')
            .usage('<lhqfile>')
            .action(async () => {
                const verbose = program.opts().verbose ?? false;
                await validateLhqModelFile(lhqfile, verbose);
            });


        program.addCommand(generateCommand);
        program.addCommand(validateCommand);


        let rootCmd = 'generate';
        if (args.length > 0 && ['generate', 'validate'].includes(args[0])) {
            rootCmd = args.shift()!;
        }

        if (isHelp || (args.length === 0 && isNullOrEmpty(lhqfile))) {
            program.outputHelp();
            process.exit(0);
        }

        if (isVersion) {
            await program.parseAsync(['--version'], { from: 'user' });
        } else {
            console.log(cliToolHeader());
            await program.parseAsync([rootCmd, ...args], { from: 'user' });
        }
    } catch (error) {
        console.error(pc.redBright((error as any).toString()));
    }
})();