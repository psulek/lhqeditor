import Handlebars, { type HelperDelegate } from 'handlebars';

import {
    hasItems,
    isNullOrEmpty,
    jsonQuery,
    type KeysMatching,
    normalizePath,
    objCount,
    removeNewLines,
    removeProperties,
    sortBy,
    sortObjectByKey,
    textEncode,
    type TextEncodeModes,
    valueOrDefault,
} from './utils.mjs';

import { AppError } from './AppError.mjs';
import { TreeElement } from './model/treeElement.mjs';
import { type OutputFileData, type OutputInlineData, TemplateRootModel } from './model/templateRootModel.mjs';
import { DefaultCodeGenSettings } from './model/modelConst.mjs';
import type { CodeGeneratorBasicSettings } from './api/modelTypes.mjs';
import type { IHostEnvironment } from './types.mjs';

// declare var HostEnvironment: IHostEnvironment;

let hostEnv: IHostEnvironment = undefined!;

export function registerHelpers(hostEnvironment: IHostEnvironment): void {
    hostEnv = hostEnvironment;
    Object.keys(helpersList).forEach(key => {
        Handlebars.registerHelper(key, helpersList[key]);
    });
}

const helpersList: Record<string, HelperDelegate> = {
    // generic helpers
    'x-header': headerHelper,
    'x-normalizePath': normalizePathHelper,
    'char-tab': charHelper,
    'char-quote': charHelper,
    'x-value': valueHelper,
    'x-join': joinHelper,
    'x-split': splitHelper,
    'x-concat': concatHelper,
    'x-replace': replaceHelper,
    'x-trimEnd': trimEndHelper,
    'x-equals': equalsHelper,
    'x-isTrue': isTrueHelper,
    'x-isFalse': isFalseHelper,
    'x-merge': mergeHelper,
    'x-sortBy': sortByHelper,
    'x-sortObject': sortObjectByKeyHelper,
    'x-objCount': objCountHelper,
    'x-hasItems': hasItemsHelper,
    'x-textEncode': textEncodeHelper,
    'x-host-webHtmlEncode': hostWebHtmlEncodeHelper,
    'x-render': renderHelper,
    'x-test': testHelper,
    'x-isNullOrEmpty': isNullOrEmptyHelper,
    'x-isNotNullOrEmpty': isNotNullOrEmptyHelper,
    'x-fn': callFunctionHelper,
    'x-logical': logicalHelper,
    'x-debugLog': debugLogHelper,
    'x-stringify': stringifyHelper,
    'x-toJson': toJsonHelper,
    'x-typeOf': typeOfHelper,

    // model specific helpers
    'm-data': modelDataHelper,
    'output': modelOutputHelper,
    'output-child': modelOutputChildHelper,
    'output-inline': modelOutputInlineHelper,
};

let _knownHelpers: KnownHelpers | undefined = undefined;

export function getKnownHelpers(): KnownHelpers {
    if (_knownHelpers === undefined) {
        _knownHelpers = Object.fromEntries(Object.keys(helpersList).map(key => [key, true]));
    }

    return _knownHelpers;
}

type HbsDataContext<T = Record<string, unknown>> = {
    name?: string;
    hash?: T;
    data?: Record<string, unknown>;
    fn?: (ctx: unknown) => unknown;
    loc?: {
        start: {
            line: number,
            column: number
        },
        end: {
            line: number,
            column: number
        }
    }
};

const fileHeader =
    `//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool - Localization HQ Editor.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------`;

function getContextAndOptions<TOptionsArgs = unknown, TContext = unknown>(context: TContext, ...args: unknown[]): { context: TContext, options: HbsDataContext<TOptionsArgs> } {
    if (args.length === 1) {
        return {
            context: context,
            options: args[0] as HbsDataContext<TOptionsArgs>
        };
    }

    return {
        context: (args[0] as TContext) ?? context,
        options: args[1] as HbsDataContext<TOptionsArgs>
    };
}

function headerHelper(options: HbsDataContext) {
    return getRoot(options).host?.['fileHeader'] ?? fileHeader;
}

type normalizePathHelperArgs = { replacePathSep?: string };

function normalizePathHelper(context: unknown, options: HbsDataContext<normalizePathHelperArgs>) {
    if (typeof context !== 'string') {
        return context;
    }

    let result = normalizePath(context);

    const replacePathSep = valueOrDefault(options.hash?.replacePathSep, '');
    if (!isNullOrEmpty(replacePathSep)) {
        result = result.split('/').join(replacePathSep);
    }

    return result;
}

type queryObjType = { query?: string };
type queryObjFlags = {
    undefinedForDefault?: boolean;
    allowHash?: boolean;
    allowFn?: boolean;
}

function queryObjValue(context: unknown, options: HbsDataContext<queryObjType>, flags?: queryObjFlags): unknown {
    const undefinedForDefault = flags?.undefinedForDefault ?? false;
    const allowHash = flags?.allowHash ?? true;
    const allowFn = flags?.allowFn ?? true;

    let value = undefinedForDefault ? undefined : context;
    let query = allowHash ? options?.hash?.query : undefined;
    if (typeof options?.fn === 'function' && allowFn) {
        query = options.fn(context) as string;
        if (!isNullOrEmpty(query) && typeof query === 'string') {
            query = removeNewLines(query);
        }
    }

    if (!isNullOrEmpty(query) && typeof query === 'string' && !isNullOrEmpty(context)) {
        try {
            value = jsonQuery(context, query);
        } catch (e) {
            const templateId = getRoot(options).currentTemplateId ?? '';
            const loc = options.loc;
            const locText = isNullOrEmpty(loc) ? '' : `starts on ${loc.start.line}:${loc.start.column}, ends: ${loc.end.line}:${loc.end.column}`;
            const msg = `Template: ${templateId}, failed on jmespath query: ${query}\n${locText}`;
            throw new Error(msg);
        }
    }

    return value;
}

function charHelper(options: HbsDataContext) {
    const name = options.name?.split('-')[1];
    switch (name) {
        case 'tab':
            return '\t';
        case 'quote':
            return '"';
        default: {
            throw new AppError(`Unknown '${options?.name}' char helper !`);
        }
    }
}

type valueHelperArgs = { default?: unknown; } & queryObjType;

function valueHelper() {
    //@ts-ignore
    const { context, options } = getContextAndOptions<valueHelperArgs>(this, ...arguments);
    const defaultValue = options.hash?.default;
    return queryObjValue(context, options) ?? defaultValue;
}

type splitHelperArgs = { sep?: string };

function splitHelper() {
    //@ts-ignore
    const { context, options } = getContextAndOptions<splitHelperArgs>(this, ...arguments);
    if (typeof context !== 'string') return context;

    const sep = valueOrDefault(options.hash?.sep, '');
    return isNullOrEmpty(sep) ? context : context.split(sep);
}

type joinHelperArgs = {
    sep?: string;
    start?: number;
    length?: number;
    end?: number;
    decorator?: string;
};

function joinHelper(items: unknown[], options: HbsDataContext<joinHelperArgs>) {
    const separator = valueOrDefault(options.hash?.sep, ',');
    const start = valueOrDefault(options.hash?.start, 0);
    const len = items ? items.length : 0;
    let end = valueOrDefault(options.hash?.end, len);
    const decorator = options.hash?.decorator || '';

    if (end > len) end = len;

    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return items.map(x => `${decorator}${x}${decorator}`).slice(start, end).join(separator);
}

type concatHelperArgs = {
    sep?: string;
    empty?: boolean;
};
const concatHelperArgsDefault: concatHelperArgs = {
    sep: '',
    empty: false
}

//function concatHelper(args: unknown[], options: HbsDataContext<concatHelperArgs>): string {
function concatHelper(...args: any[]): string {
    const options = args.pop() as HbsDataContext<concatHelperArgs>;
    const hash: concatHelperArgs = Object.assign({}, concatHelperArgsDefault, options.hash ?? {});
    const array = hash.empty ? args : args.filter(x => !isNullOrEmpty(x));

    removeProperties(options.hash, hash);
    options.hash = { sep: hash.sep };

    return joinHelper(array, options);
}

type replaceHelperArgs = {
    what?: string;
    with?: string;
    opts?: string;
}

function replaceHelper(value: string, options: HbsDataContext<replaceHelperArgs>): string {
    const what = valueOrDefault(options.hash?.what, '');
    const withStr = valueOrDefault(options.hash?.with, '');
    const regexopts = valueOrDefault(options.hash?.opts, 'g');
    const hasOpts = !isNullOrEmpty(options.hash?.opts);

    if (isNullOrEmpty(what) || isNullOrEmpty(withStr) || (what === withStr && !hasOpts)) {
        return value;
    }

    const regex = new RegExp(what, regexopts);
    return value.replace(regex, withStr);
}

function trimEndHelper(input: string, endPattern: string): string {
    try {
        const regex = new RegExp(endPattern + '$');
        return input.replace(regex, '');
    } catch (error) {
        hostEnv.debugLog('Invalid regex pattern:' + endPattern);
        return input;
    }
}

type equalsHelperArgs = {
    cs?: boolean;
}

function equalsHelper(input: unknown, value: unknown, options: HbsDataContext<equalsHelperArgs>): boolean {
    const cs = (options.hash?.cs || 'true').toString().toLowerCase() == 'true';
    const val1 = typeof input === 'string' ? input : (input?.toString() ?? '');
    const val2 = typeof value === 'string' ? value : (value?.toString() ?? '');

    return cs ? val1 === val2 : (val1.toLowerCase() === val2.toLowerCase());
}

function isTrueHelper(input: unknown): boolean {
    return input === true;
}

function isFalseHelper(input: unknown): boolean {
    return input === false
}

type logicalHelperArgs = {
    op?: 'and' | 'or';
}

function logicalHelper(input: unknown, value: unknown, options: HbsDataContext<logicalHelperArgs>): boolean {
    const op = valueOrDefault(options.hash?.op, 'and').toLowerCase();
    if (op === 'and') {
        return (input === true) && (value === true);
    } else if (op === 'or') {
        return (input === true) || (value === true);
    }

    return false;
}

function mergeHelper(...args: any[]): unknown {
    const options = args.pop() as HbsDataContext;
    // @ts-ignore
    const context = args.length === 0 ? this : args.shift();

    if (typeof context !== 'object') return context;
    if (isNullOrEmpty(context)) return context;

    Object.assign(context, ...args, options.hash ?? {});

    let result: unknown | undefined;
    if (typeof options?.fn === 'function') {
        try {
            result = options.fn(context);
        } finally {
            removeProperties(context, ...args, options.hash ?? {});
        }
    }

    return result;
}

function sortByHelper<T>(source: T[], propName?: KeysMatching<T, string | number>, sortOrder: 'asc' | 'desc' = 'asc'): T[] {
    return sortBy<T>(source, propName, sortOrder);
}

type sortObjectByKeyHelper = {
    sortOrder?: 'asc' | 'desc';
}

function sortObjectByKeyHelper(obj: Record<string, unknown>, options: HbsDataContext<sortObjectByKeyHelper>): Record<string, unknown> {
    const sortOrder = valueOrDefault(options.hash?.sortOrder, 'asc');
    return sortObjectByKey(obj, sortOrder);
}

function objCountHelper<T>(obj: Record<string, T> | Array<T> | undefined): number {
    return objCount<T>(obj);
}

function hasItemsHelper<T>(obj: Record<string, T> | Array<T> | undefined): boolean {
    return hasItems<T>(obj);
}

type textEncodeHelperArgs = {
    mode?: TextEncodeModes;
    quotes?: boolean;
}

export function textEncodeHelper(input: string, options: HbsDataContext<textEncodeHelperArgs>): Handlebars.SafeString {
    const mode = valueOrDefault<TextEncodeModes>(options?.hash?.mode, 'html');
    const quotes = valueOrDefault(options?.hash?.quotes, false);
    const s = textEncode(input, { mode: mode, quotes });
    return new Handlebars.SafeString(s);
}

function hostWebHtmlEncodeHelper(input: string): Handlebars.SafeString | string {
    if (isNullOrEmpty(input)) {
        return input;
    }

    const encoded = hostEnv.webHtmlEncode(input);
    return new Handlebars.SafeString(encoded);
}

type renderHelperArgs = {
    when?: boolean;
}

function renderHelper(input: string, options: HbsDataContext<renderHelperArgs>): string {
    const when = valueOrDefault(options.hash?.when, true);
    return (!isNullOrEmpty(when) && (when === true || when === 'true')) ? input : '';
}

type testHelperArgs = {
    then?: unknown;
    else?: unknown;
}

function testHelper(): string {
    //@ts-ignore
    const { context, options } = getContextAndOptions<testHelperArgs>(this, ...arguments);
    const condition = context;

    if (isNullOrEmpty(options.hash) || isNullOrEmpty(condition)) {
        return '';
    }

    const then = valueOrDefault(options.hash?.then, '');
    const _else = valueOrDefault(options.hash?.else, '');

    return condition === true ? then : _else;
}

function isNullOrEmptyHelper<T>(value: T | null | undefined | ''): value is undefined | null | '' {
    return isNullOrEmpty(value);
}

function isNotNullOrEmptyHelper(input: unknown): boolean {
    return !isNullOrEmpty(input);
}

function callFunctionHelper(fn: Function, ...args: unknown[]): unknown {
    let fnArgs: unknown[] = [];
    if (arguments.length > 0) {
        fnArgs = args.slice(0, -1);
    }

    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    return fnArgs.length === 0 ? fn() : fn(...fnArgs);
}

function debugLogHelper(...args: unknown[]): string {
    hostEnv.debugLog(args.join(' '));
    return '';
}

function getRoot(options: HbsDataContext): TemplateRootModel {
    if (isNullOrEmpty(options) || isNullOrEmpty(options?.data)) {
        throw new AppError('Template has unknown definition for root data !');
    }

    return options.data['root'] as TemplateRootModel;
}

type stringifyHelperArgs = {
    space?: number | string | undefined;
}

function stringifyHelper() {
    //@ts-ignore
    const { context, options } = getContextAndOptions<stringifyHelperArgs>(this, ...arguments);
    let space = options.hash?.space ?? undefined;

    if (typeof space === 'string') {
        space = space.replace(/\\\\t/gm, '\t');
    }

    return new Handlebars.SafeString(JSON.stringify(context, null, space));
}

function toJsonHelper(context: unknown) {
    if (typeof context === 'string') {
        return JSON.parse(context);
    }

    return context;
}

function typeOfHelper(context: unknown) {
    if (context === undefined) {
        return 'undefined';
    }
    if (context === null) {
        return 'null';
    }

    if (typeof context === 'object') {
        return context.constructor ? context.constructor.name : 'object';
    } else {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
        return context === undefined ? 'undefined' : `${context}[${typeof context}]`;
    }
}

type modalDataHelperArgs = {
    key: string;
    default?: unknown;
    root?: boolean;
} & queryObjType;

function modelDataHelper() {
    //const { context, options } = getContextAndOptions<modalDataHelperArgs>(this, ...args);
    // @ts-ignore
    const { context, options } = getContextAndOptions<modalDataHelperArgs>(this, ...arguments);


    const defaultValue = options.hash?.default;
    const value = queryObjValue(context, options) ?? defaultValue;
    const forceToRoot = valueOrDefault(options.hash?.root, false);

    const key = options?.hash?.key ?? '';
    if (isNullOrEmpty(key)) {
        throw new AppError(`Helper '${options.name}' missing hash param 'key' !`);
    }

    // @ts-ignore
    setCustomData(this, options, value, forceToRoot);
}

function setCustomData(context: any, options: HbsDataContext, valueOrFn: () => any | any, forceToRoot: boolean): void {
    const value = typeof valueOrFn === 'function' ? valueOrFn() : valueOrFn;
    const key = valueOrDefault(options?.hash?.key, '');

    if (!isNullOrEmpty(key)) {
        if (forceToRoot) {
            const root = getRoot(options);
            root.addToTempData(key, value);
        } else if (context instanceof TreeElement) {
            context.addToTempData(key, value);
        } else if (context instanceof TemplateRootModel) {
            context.addToTempData(key, value);
        } else {
            hostEnv.debugLog(`[setCustomData] unknown context: ${typeof context} for key '${key}' !`);
        }
    }
}

type modelOutputArgs = {
    fileName: string;
    mergeWithDefaults: boolean;
    settings?: CodeGeneratorBasicSettings
} & queryObjType;


const modelOutputFlags: queryObjFlags = { undefinedForDefault: true, allowHash: false };

function modelOutputHelper() {
    //@ts-ignore
    const { context, options } = getContextAndOptions<modelOutputArgs>(this, ...arguments);

    if (!(context instanceof TemplateRootModel)) {
        throw new AppError(`Helper '${options.name}' can be used only on TemplateRootModel (@root) type !`);
    }

    if (context.inlineEvaluating) {
        throw new AppError(`Helper '${options.name}' cannot be used as a child helper inside 'output-inline' helper !`);
    }

    if (isNullOrEmpty(options.hash)) {
        throw new AppError(`Helper '${options.name}' missing hash properties !`);
    }

    const fileName = options?.hash?.fileName ?? '';

    const settingsNode = context.model.codeGenerator?.settings;
    const settingsObj = options.hash?.settings ?? queryObjValue(settingsNode, options, modelOutputFlags);

    let outputFile: OutputFileData = context.output!;
    let updateSettings = true;

    if (outputFile) {
        if (fileName !== undefined) {
            outputFile.fileName = fileName;

            if (settingsObj === undefined) {
                updateSettings = false;
            }
        }
    } else {
        outputFile = {
            fileName: fileName,
            settings: undefined
        };

        updateSettings = !isNullOrEmpty(settingsObj);
    }

    if (updateSettings) {
        if (isNullOrEmpty(settingsObj)) {
            throw new AppError(`Helper '${options.name}' must have child content with jmespath query expression to ` +
                `retrieve settings (must be compatible with CodeGeneratorBasicSettings type) !`);
        }

        const mergeWithDefaults = options.hash?.mergeWithDefaults ?? true;
        const settings = Object.assign({}, mergeWithDefaults ? DefaultCodeGenSettings : {}, settingsObj) as CodeGeneratorBasicSettings;
        outputFile.settings = settings;
    }

    if (isNullOrEmpty(outputFile.fileName) && isNullOrEmpty(outputFile.settings)) {
        throw new AppError(`Helper '${options.name}' missing hash property 'fileName' or 'settings' or child content with jmespath query expression !`);
    }

    context.setOutput(outputFile);
}

function modelOutputChildHelper(options: HbsDataContext<{ templateId: string, host?: Record<string, unknown> }>) {
    const context = getRoot(options);

    if (!(context instanceof TemplateRootModel)) {
        throw new AppError(`Helper '${options.name}' can be used only on TemplateRootModel (@root) type !`);
    }

    if (context.inlineEvaluating) {
        throw new AppError(`Helper '${options.name}' cannot be used as a child helper inside 'output-inline' helper !`);
    }

    if (typeof options?.fn === 'function') {
        throw new AppError(`Helper '${options.name}' cannot be used as block helper (no child content is allowed) !`);
    }

    if (isNullOrEmpty(options.hash)) {
        throw new AppError(`Helper '${options.name}' missing hash properties !`);
    }

    const templateId = options.hash?.templateId;
    if (isNullOrEmpty(templateId)) {
        throw new AppError(`Helper '${options.name}' missing hash property 'templateId' !`);
    }

    context.addChildOutput(templateId, options.hash?.host);
}


type modelOutputInlineArgs = modelOutputArgs;

const modelOutputInlineFlags: queryObjFlags = { undefinedForDefault: true, allowHash: true, allowFn: false };

function modelOutputInlineHelper() {
    //@ts-ignore
    const { context, options } = getContextAndOptions<modelOutputInlineArgs>(this, ...arguments);

    if (!(context instanceof TemplateRootModel)) {
        throw new AppError(`Helper '${options.name}' can be used only on TemplateRootModel (@root) type !`);
    }

    if (arguments.length > 1) {
        throw new AppError(`Helper '${options.name}' can be only use as block helper (value must be child of '${options.name}' begin/end tags) !`);
    }

    const fileName = options.hash?.fileName ?? '';
    if (isNullOrEmpty(fileName)) {
        throw new AppError(`Helper '${options.name}' missing property 'fileName' !`);
    }

    if (typeof options?.fn !== 'function') {
        throw new AppError(`Helper '${options.name}' can be only use as block helper (value must be child of '${options.name}' begin/end tags) !`);
    }

    const settingsNode = context.model.codeGenerator?.settings;
    let settingsObj = options.hash?.settings ?? queryObjValue(settingsNode, options, modelOutputInlineFlags);

    if (isNullOrEmpty(settingsObj)) {
        // get settings from root template if not found on 'ouput-inline' helper...
        settingsObj = getRoot(options).settings;

        if (isNullOrEmpty(settingsObj)) {
            throw new AppError(`Helper '${options.name}' could not find code gen settings from query (nor root settings) !`);
        }
    }

    const mergeWithDefaults = options?.hash?.mergeWithDefaults ?? true;
    const settings = Object.assign({}, mergeWithDefaults ? DefaultCodeGenSettings : {}, settingsObj) as CodeGeneratorBasicSettings;

    let fileContent = '';
    if (context.setInlineEvaluating(true)) {
        try {
            fileContent = options.fn(context) as string ?? '';
        } catch (e) {
            throw new AppError(`Helper '${options.name}' error: ${(e as Error).message}`);
        } finally {
            context.setInlineEvaluating(false);
        }
    } else {
        throw new AppError(`Helper '${options.name}' cannot be used as a child helper inside another '${options.name}' helper !`);
    }

    const inlineOutput: OutputInlineData = {
        fileName: fileName,
        settings: settings,
        content: fileContent
    };

    context.addInlineOutputs(inlineOutput);
}